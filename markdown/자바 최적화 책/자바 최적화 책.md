## 2.1 인터프리팅과 클래스 로딩

- 자바 애플리케이션은 실행하면, OS는 가상 머신 프로세스인, **자바 바이너리**를 구동함
- 자바 클래스로딩 메커니즘
  - 자바 프로세스가 새로 초기화되면서 사슬처럼 연결된 클래스로더들이 작동함
  - **부트스트랩 클래스**가 가장 먼저 자바 런타임 코어 클래스를 로더
    - 부트스트랩 클래스로더의 주임무는, 다른 클래스로더가 나머지 시스템에 필요한 클래스 로드할 수 있게, **최소한의 필수 클래스**만 로드함	
  - 그 다음으로 **확장클래스로더**가 **부트스트랩 클래스로더를 부모로 설정**하고, 필요할 때 클래스로딩 작업을 부모에게 넘긴다.
    - 자바는 프로그램 실행 중 처음 보는 새 클래스를 `dependency`(의존체)에 로드함
    - 없으면 부모 클래스로더에게 대신 룩업을 넘김
      - 그렇게해도 못 찾을 경우 `ClassNotFoundException`이 발생함

​	

---

- 최근 수년 간 소프트웨어 개발자들은 더 나은 성능을 얻기 위해 하드웨어 작동 원리를 깊이 이해하려고 한다
  - 이를 기계공감이라고 함

- **context switching**은 OS 스케줄러가 현재 실행 중인 스레드/테스클를 없애고 대기 중인 다른 스레드/테스크로 대체하는 프로세스다.
  - 비싼 작업이다.

- 애플리케이션이 잘 돌아간다는 건 CPU 사용량, 메모리, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻

- 성능 진단의 첫 단추는 어느 리소스가 한계에 다다랐는지 밝히는 일입니다.
- 성능 엔지니어라면, `vmstat` , `iostat` 정도는 쓸 줄 알아야 함

- `vmstat` 설명

  1. **proc**  섹션: 실행 가능한(r) 프로세스, 블로킹도닌(b) 프로세스 개수를 나타냅니다.

  2. **memory** 섹션: 

     1. **swap** 섹션: 디스크로 교체되어 들어간(**swap-in**) 메모리(si), 디스크에서 교체되어 빠져나온 (**swap-out**) 메모리(so) 정보

        - swap-out : **요청받는 메모리 > 사용 가능한 물리적 메모리**보다 큰 경우, 현재 필요 없는 페이지를 느리지만, 용량이 큰 디스크로 옮기는 것
        - swap-in: 스왑 아웃한 페이지에 프로그램이 접근하면 필요한 메모리 공간을 확보하고 해당 페이지를 다시 메모리로 불러들이는 것

        - 최신 서버급 머신은 보통 스왑이 안 발생한다고 함

     2. **io** 섹션: block-in(bi), block-out(bo) 개수는 각가 블록(I/O) 장치에서 받은 512 바이트 블록, 블록 장치에 보낸 512바이트 블록 개수

     3. **system** 섹션: interrupt(in) 및 초당 context switching(cs) 횟수

     4. **cpu** 섹션: CPU와 직접 연관된 지표를 CPU 사용률로 표기함

        - 유저 시간(us), 커널 시간(sy), 유휴 시간(id), 대기 시간(wa), 도둑맞은 시간(st, 가상 머신에 할애된 시간)

        - [[linux kernel\] (1) - 커널(kernel)이란? (tistory.com)](https://jiravvit.tistory.com/entry/linux-kernel-1-커널kernel이란-1)

          - **유저 모드 이란?**

            - 일반 사용자 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있음

          - **커널 모드 이란?**

            - 운영 체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드로, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있음.

            

- 튜닝이 잘된 프로그램은 리소스, 특히 CPU를 최대한 활용합니다.