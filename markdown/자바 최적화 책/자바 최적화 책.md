## 2.1 인터프리팅과 클래스 로딩

- 자바 애플리케이션은 실행하면, OS는 가상 머신 프로세스인, **자바 바이너리**를 구동함
- 자바 클래스로딩 메커니즘
  - 자바 프로세스가 새로 초기화되면서 사슬처럼 연결된 클래스로더들이 작동함
  - **부트스트랩 클래스**가 가장 먼저 자바 런타임 코어 클래스를 로더
    - 부트스트랩 클래스로더의 주임무는, 다른 클래스로더가 나머지 시스템에 필요한 클래스 로드할 수 있게, **최소한의 필수 클래스**만 로드함	
  - 그 다음으로 **확장클래스로더**가 **부트스트랩 클래스로더를 부모로 설정**하고, 필요할 때 클래스로딩 작업을 부모에게 넘긴다.
    - 자바는 프로그램 실행 중 처음 보는 새 클래스를 `dependency`(의존체)에 로드함
    - 없으면 부모 클래스로더에게 대신 룩업을 넘김
      - 그렇게해도 못 찾을 경우 `ClassNotFoundException`이 발생함

​	

## 2.2 바이트코드 실행

- 자바 소스 코드의 실행은 `javac`를 이용해 `바이트 코드`로 컴파일하는 것으로부터 시작된다.
  - `.java` 에서 `.class` 로 바꾸는 것이다.
- 바이트 코드는 컴퓨터 아키텍처의 지배를 받지 않아, 이식성이 좋고 JVM 지원 플랫폼이면 어디든지 실행 가능
  - 호환되지 않는 버전의 클래스 파일을 만나면 런타임에 `UnsupportedClassVersionError` 예외가 발생함

### JIT ( Just In Time) 컴파일이란?

- 자바 프로그램은 `바이트코드 인터프리터`가 `가상화된 스택 머신`에서 명령어를 실행함
  - `바이트코드 인터프리터`는 CPU를 추상화한 구조이기 때문에 다른 클래스 파일을 문제없이 실행할 수 있지만, 성능을 최대화를 위해서는 네이티브 기능을 활용한 CPU에서 직접 프로그램을 실행시켜야함
- 이를 위해 핫스팟 가상머신에서 **프로그램 단위** (메서드와 루프)를 `인터프리티드 바이트코드에서 네이티브 코드`로 컴파일함. => 이를 **JIT 컴파일**이라고 함
  - 핫스팟 JVM은 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행함
  - 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정한다는 것



---

## 3.6  기본 감지 전략

- 최근 수년 간 소프트웨어 개발자들은 더 나은 성능을 얻기 위해 하드웨어 작동 원리를 깊이 이해하려고 한다
  - 이를 기계공감이라고 함

- **context switching**은 OS 스케줄러가 현재 실행 중인 스레드/테스클를 없애고 대기 중인 다른 스레드/테스크로 대체하는 프로세스다.
  - 비싼 작업이다.

- 애플리케이션이 잘 돌아간다는 건 CPU 사용량, 메모리, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻

### 3.6.1  CPU 사용률

- 성능 진단의 첫 단추는 어느 리소스가 한계에 다다랐는지 밝히는 일입니다.
- 성능 엔지니어라면, `vmstat` , `iostat` 정도는 쓸 줄 알아야 함

- `vmstat` 설명

  1. **proc**  섹션: 실행 가능한(r) 프로세스, 블로킹도닌(b) 프로세스 개수를 나타냅니다.

  2. **memory** 섹션: 

     1. **swap** 섹션: 디스크로 교체되어 들어간(**swap-in**) 메모리(si), 디스크에서 교체되어 빠져나온 (**swap-out**) 메모리(so) 정보

        - swap-out : **요청받는 메모리 > 사용 가능한 물리적 메모리**보다 큰 경우, 현재 필요 없는 페이지를 느리지만, 용량이 큰 디스크로 옮기는 것
        - swap-in: 스왑 아웃한 페이지에 프로그램이 접근하면 필요한 메모리 공간을 확보하고 해당 페이지를 다시 메모리로 불러들이는 것

        - 최신 서버급 머신은 보통 스왑이 안 발생한다고 함

     2. **io** 섹션: block-in(bi), block-out(bo) 개수는 각가 블록(I/O) 장치에서 받은 512 바이트 블록, 블록 장치에 보낸 512바이트 블록 개수

     3. **system** 섹션: interrupt(in) 및 초당 context switching(cs) 횟수

     4. **cpu** 섹션: CPU와 직접 연관된 지표를 CPU 사용률로 표기함

        - 유저 시간(us), 커널 시간(sy), 유휴 시간(id), 대기 시간(wa), 도둑맞은 시간(st, 가상 머신에 할애된 시간)

        - [[linux kernel\] (1) - 커널(kernel)이란? (tistory.com)](https://jiravvit.tistory.com/entry/linux-kernel-1-커널kernel이란-1)

          - **유저 모드 이란?**

            - 일반 사용자 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있음

          - **커널 모드 이란?**

            - 운영 체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드로, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있음.

            

- 튜닝이 잘된 프로그램은 리소스, 특히 CPU를 최대한 활용합니다.

- 대다수 OS (특히 리눅스에서 ) `vmstat`는  **context swtiching** 횟수를 나타내고, `vmstat 1 `로 실시간 **context swiching**을 알 수 있다. 

  - 유저 공간에서 CPU 사용률이 100% 근처도 못 갔는데, 어떤 프로세스에서 **context swtiching** 비율이 높게 나타내면, I/O 블로킹이 일어났거나, thread lock contention 상황이 벌어졌을 가능성이 있다.

### 3.6.2 가비지 수집

- 어떤 시스템에서 CPU 사용률이 아주 높게 나타난다면, GC가 주범은 아니다.
  - GC자체는 유저 공간의 CPU 사이클을 소비하되 커널 공간의 사용률에 영향을 미치지 않는 활동이라고 함
- 반면, 어떤 JVM 프로세스가 유저 공간에서 CPU를 100% 가까이 사용하고 있다면 GC를 의심해야 합니다.